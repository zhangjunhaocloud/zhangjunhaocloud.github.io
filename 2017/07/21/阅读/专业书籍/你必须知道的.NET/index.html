<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>你必须知道的.NET | 云顶小栈 | 小栖片刻</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C#,阅读,专业书籍">
    <meta name="description" content="ol li{     margin:6px; }    对象常见类型分为值类型和引用类型两种，其依据是对象在运行时在内存中的位置，值类型位于线程的堆栈中，而引用类型位于托管堆  C#访问修饰符主要为：public、protected、internal、protected internal、private五种  对象中的多态主要包括：A、接口实现多态 B、抽象类实现多态    继承，就是面向对象中">
<meta property="og:type" content="article">
<meta property="og:title" content="你必须知道的.NET">
<meta property="og:url" content="https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/index.html">
<meta property="og:site_name" content="云顶小栈">
<meta property="og:description" content="ol li{     margin:6px; }    对象常见类型分为值类型和引用类型两种，其依据是对象在运行时在内存中的位置，值类型位于线程的堆栈中，而引用类型位于托管堆  C#访问修饰符主要为：public、protected、internal、protected internal、private五种  对象中的多态主要包括：A、接口实现多态 B、抽象类实现多态    继承，就是面向对象中">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-07-21T11:51:00.000Z">
<meta property="article:modified_time" content="2020-10-26T09:52:09.077Z">
<meta property="article:author" content="张峻豪">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="阅读">
<meta property="article:tag" content="专业书籍">
<meta name="twitter:card" content="summary">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">张峻豪</h5>
          <a href="mailto:zhangjunhaocloud@outlook.com" title="zhangjunhaocloud@outlook.com" class="mail">zhangjunhaocloud@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/zhangjunhaocloud" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">你必须知道的.NET</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">你必须知道的.NET</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-07-21T11:51:00.000Z" itemprop="datePublished" class="page-time">
  2017-07-21
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E5%8E%9F%E5%88%9B/">原创</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    

<article id="post-阅读/专业书籍/你必须知道的.NET"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">你必须知道的.NET</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-07-21 19:51:00" datetime="2017-07-21T11:51:00.000Z"  itemprop="datePublished">2017-07-21</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E5%8E%9F%E5%88%9B/">原创</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <style>
ol li{
    margin:6px;
}
</style>

<ul>
<li><p>对象常见类型分为<code>值类型</code>和<code>引用类型</code>两种，其依据是对象在运行时<code>在内存中的位置</code>，<code>值类型</code>位于线程的<code>堆栈</code>中，而<code>引用类型</code>位于<code>托管堆</code></p>
</li>
<li><p>C#访问修饰符主要为：<code>public</code>、<code>protected</code>、<code>internal</code>、<code>protected internal</code>、<code>private</code>五种</p>
</li>
<li><p>对象中的<code>多态</code>主要包括：A、接口实现多态 B、抽象类实现多态  </p>
</li>
<li><p><code>继承</code>，就是面向对象中类与类之间的一种关系。继承的类称为子类、派生类，而被继承类称为父类、基类或超类。通过继承，使得子类具有父类的属性和方法，同时子类也可以通过加入新的属性和方法或修改父类的属性和方法建立新的类层次</p>
</li>
<li><p><code>继承</code>按照<code>实现方式</code>的不同一般分为：A、<code>实现继承</code> B、<code>接口继承</code></p>
</li>
<li><p>CLR支持<code>实现单继承</code>和<code>接口多继承</code></p>
</li>
<li><p><code>继承</code>实现了代码的<code>复用</code>和<code>扩展</code>，<code>重载(overload)</code>、<code>覆写(override)</code>、<code>接口实现</code>等方式实现了<code>封装变化</code></p>
</li>
<li><p>继承的本质：A、继承是可传递的，子类是对父类的扩展，必须继承父类方法，同时可以添加新方法；B、子类可以调用父类方法和字段，而父类不能调用子类方法和字段；C、虚方法如何实现覆写操作，使得父类指针可以指向子类对象成员；D、子类不光继承父类的公有成员，同时继承了父类的私有成员，只是在子类中不被访问；E、new关键字在虚方法继承中的阻断作用</p>
</li>
<li><p>在子类方法中，如果标记<code>new</code>关键字，则意味着<code>隐藏基类实现</code>，其实就是创建了与父类同名的另一个方法</p>
</li>
<li><p><code>实现继承</code>与<code>接口继承</code>规则归纳：A、抽象类适合于族层概念的类间关系，而接口最适合为不同的类型提供通用功能；B、接口着重于CAN-DO关系类型，而抽象类型则偏重于IS-A式的关系；C、接口多定义对象的行为；抽象类多定义对象的属性；D、如果预计会出现版本问题，可以创建“抽象类”；E、因为值类型是密封的，所以只能实现接口，而不能继承类</p>
</li>
<li><p><code>继承的缺点</code>：A、继承可能造成子类的无限膨胀，不利于体系的维护和安全；B、继承的子类对象确定于编译期，无法满足需要运行期才确定的情况，而类聚合很好地解决了这一问题；C、随着继承层次的复杂化和子类的多样化，不可避免地会出现对父类的无效继承或者有害继承</p>
</li>
<li><p><code>继承归纳</code>：A、密封类不可以被继承；B、继承关系中，我们更多的是关注其共性而不是特性，因为共性是层次复用的基础，而特性是系统扩展的基点；C、实现单继承，接口多继承；D、从宏观来看，继承多关注于共通性；而多态多着眼于差异性；E、继承的层次应该有所控制，否则类型之间的关系维护会消耗更多的精力；F、面向对象原则：多组合，少继承；低耦合，高内聚。</p>
</li>
<li><p><code>封装的意义</code>：A、字段通常定义为private，属性通常实现为public，而方法在内部实现为private，对外部实现为public，从而保证对内部数据的可靠性读写控制，保护了数据的安全和可靠，同时又提供了与外部接口的有效交互；B、从内存和数据持久性角度来看，封装属性提供了数据持久化的有效字段；C、隐藏系统实现的细节，保证系统的安全性和可靠性；D、提供稳定不变的对外接口；E、封装保证了代码模块化，提高了软件的复用和功能分离。</p>
</li>
<li><p><code>封装的主旨</code>：A、隐藏系统实现的细节，保证系统的安全性和可靠性  B、提供稳定不变的对外接口 C、封装保证了代码模块化，提高了软件的复用和功能分离</p>
</li>
<li><p><code>封装的规则</code>：A、尽可能地调用类的访问器，而不是成员，即使在类的内部；B、内部私有部分可以任意更改，但是一定要在保证对外接口稳定的前提下；C、将对字段的读写控制实现为属性，而不是方法，否则舍近而求远，非明智之选；D、类封装是由访问权限来访问的，对内实现为private，对外实现为public；E、封装的精华是封装变化</p>
</li>
<li><p><code>封装</code>：封装就是一个包装，将包装的内外分为两个空间，对内实现数据私有，对外实现方法调用，保证了数据的完整性和安全性。</p>
</li>
<li><p><code>多态的分类</code>(按实现的方式)：A、<code>基类继承式</code>多态和<code>接口实现式</code>多态</p>
</li>
<li><p><code>动态绑定</code>，又叫晚期绑定，是区别于静态绑定而言的。静态绑定在编译期就可以确定关联，一般是以方法重载来实现的；而动态绑定则在运行期间通过检查虚拟方法表来确定动态关联覆写的方法，一般以继承和虚方法来实现。</p>
</li>
<li><p><code>多态的规则和意义</code>：A、多态提供了对同一类对象的差异化处理方式，实现了对变化和共性的有效封装和继承，体现了“一个接口，多种方法”的思想，使方法抽象机制成为可能；B、在.NET中，默认情况下方法是非虚的，以C#为例必须显式地通过virtual或者abstract标记为虚方法或者抽象方法，以便在子类中覆写父类方法；C、在面向对象的基本要素中，多态和继承、多态和重载存在紧密的联系</p>
</li>
<li><p><code>接口的规则</code>：A、接口隔离原则强调接口应该被实现为具有单一功能的小接口，而不要实现为具有多个功能的胖接口，类对于类的依赖应建立在最小的接口上；B、接口支持多继承，既可以作用于值类型，也可以作用于引用类型；C、禁止为已经发布的接口，添加新的成员，这意味着你必须重新修改所有实现了接口的类型，在实际的应用中，这往往是不可能完成的事情；D、接口不能被实例化，没有构造函数，接口成员被隐式声明为public</p>
</li>
<li><p>设计原则<br>A. <code>单一职责原则</code>(SRP,Single Responsibility Principle)：一个类应该仅有一个引起它变化的原因。不要将变化原因不同的职责封装在一起，而应该分离<br>B.<code>开放封闭原则</code>(OCP,Open Closed Principle)：软件实体应当对修改关闭，对扩展开放<br>C.<code>依赖倒置原则</code>(DIP,Dependency Inversion Principle)：依赖于抽象，而不要依赖于具体，因为抽象相对稳定<br>D.<code>Liskov替换原则</code>(LSP,Liskov Substitution Principle)：子类必须能够替换其基类<br>E.<code>接口隔离原则</code>(ISP,Interface Segregation Principle)：尽量应用专门的接口，而不是单一的总接口，接口应该而向用户，将依赖建立在最小的接口上<br>F.<code>合成/聚合利用原则</code>(CARP,Composite/Aggregate Reuse Principle)：在新对象中聚合已有对象，使之成为新对象的成员，从而通过操作这些对象达到复用的目的。合成方式较继承方式耦合更松散，所以应该少继承，多聚合<br>G.<code>迪米特法则</code>(Lod,Law of Demeter)：又叫最少知识原则，指软件实体应该尽可能少的和其他软件实体发生相互作用  </p>
</li>
<li><p>单一职责原则的建议：一个类只有一个引起它变化的原因，否则就应当考虑重构。SRP由引起变化的原因决定，而不由功能职责决定。虽然职责常常是引起变化的轴线，但是有时却未必，应该审时度势。测试驱动开发，有助于实现合理分离功能的设计。可以通过Facade模式或Proxy模式进行职责分离  </p>
</li>
<li><p>开放封闭原则的建议：开放封闭原则，是最为重要的设计原则，Liskov替换原则和合成/聚合复用原则为开放封闭原则的实现提供保证。可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭、对扩展开放的设计思路。封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态一般将其封装为一个抽象。拒绝滥用抽象，只将经常变化的部分进行抽象，这种经验可以从设计模式的学习与应用中获得 </p>
</li>
<li><p>依赖倒置原则的建议：抽象的稳定性决定了系统的稳定性，因为抽象是保持不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心思想。依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一成不变的。依赖于抽象，就是要对接口编程，不要对实现编程。</p>
</li>
<li><p>接口隔离原则的建议：将功能相近的接口合并，可能造成接口污染，实现内聚的接口才是接口设计的基本原则。接口隔离原则，能够保证系统扩展和修改的影响不会扩展到系统的其他部分，一定程度上保证了对开放封闭原则的遵守。</p>
</li>
<li><p>Liskov原则的建议：Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必须导致违反开放封闭原则。Liskov替换原则能够保证系统具有良好的扩展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型差别。子类必须满足基类和客户端对其的行为约定，客户端对行为的期望在基类和子类必须保持一致。IS-A是基于行为方式的，它依赖于客户端的调用方式，对象的行为方式才是值得关注的要素。子类的异常必须控制在父类可以预计的范围，否则将导致替换违规，返反了Liskov替换原则。</p>
</li>
<li><p><code>抽象</code>就是系统中对变化封闭的战略逻辑，体现了系统的必然性和稳定性，能够被具体层次复用和覆写；而具体则包含了与具体实现相关的逻辑，体现了系统的动态性和变动性。</p>
</li>
<li><p><code>控制反转</code>，简言之就是代码的控制器交由系统控制，而不是在代码内部，通过IoC，消除组件或模块间的直接依赖，使得软件系统的开发更具柔性和扩展性。</p>
</li>
<li><p>常见的三种<code>依赖注入</code>方式：A、<code>接口注入</code>(Interface Injection),将对象间的关系转移到一个接口，以接口注入控制；B、<code>构造器注入</code>(Constructor Injection),客户类在类型构造时，将服务类实例以构造函数参数的形式传递给客户端，因此服务类实例一旦注入将不可修改;C、<code>属性注入</code>(Setter Injection),通过客户类属性设置的方式，将服务器实例在运行时设定的客户类属性，相较构造器注入方式，属性注入提供了改写服务器实例的可能。</p>
</li>
<li><p><code>DIP、IoC、DI</code>关系：<code>DIP</code>是对于依赖关系的<code>理论总结</code>，而<code>IoC</code>和<code>DI</code>则实例为<code>具体的实践模式</code>。IoC和DI为消除模块或者类之间的耦合关系提供了有效的解决方案，从而保证了依赖于抽象和稳定模块或者类型，也就意味着坚持了DIP原则的大方向。而<code>IoC</code>和<code>DI</code>之间的<code>区别</code>主要体现在<code>关注场合</code>的不同：<code>IoC</code>强调<code>控制权的反转作用</code>，着眼于流程控制的场合；而<code>DI</code>则关注<code>层次与层次</code>、<code>组件与组件</code>、<code>模块与模块</code>或者<code>类型与类型</code>之间的”倒置”，体现为设计模型上的依赖模式解构</p>
</li>
<li><p>模式的依赖<br>A. <code>创建型模式</code>：创建型模式的核心关注点就在于对象创建的依赖关系上，将对象的依赖从new操作中解脱出来，隔离应用系统和类型实例化间的依赖。(工厂方法、抽象工厂、单例、创建者、原型模式)<br>B. <code>结构型模式</code>：结构型模式，是将简单类型组合为复杂类型的过程，通过灵活的设计要素，最终保证不同类型间保持尽量间接的引用和尽量松散的耦合，在复杂类型有更多变化与诉求时，以最小的代价兼容变化，扩展诉求。(桥接、适配器、组合、外观、装饰、享元、代理)<br>C. <code>行为型模式</code>：行为型模式，关注对象行为的扩展和对象间数据关系的通信，以面向对象方式描述控制流。(模板方法、迭代器、中介者、职责链、解释器命令、观察者、备忘录、状态、策略、访问者)</p>
</li>
<li><p>关于依赖简单总结：A、以new创建对象，是对依赖倒置原则的典型违反，可以通过工厂模式或者依赖注入来解决；B、一个对象持有另外一个具体对象的引用可能破坏了依赖倒置；C、所有结构良好的面向对象架构都具有清晰的层次定义，每个层次通过一个定义良好的受控接口向外提供一组内聚的服务；D、依赖倒置预示着程序中的依赖关系不应是具体的类型，而应是抽象类和接口；E、依赖倒置适用于当一个类向另一个类发送消息的任何情况</p>
</li>
<li><p><code>工厂方法</code>(Factory Method Pattern)：<code>模式起点</code>：将程序中创建对象的操作单独进行处理，大大提高了系统扩展的柔性，接口的抽象化处理给相互依赖的对象创建提供了最好的抽象模式。典型应用：工厂方法模式是最简单也最容易理解的模式之一。其关注的核心是对于对象创建这件事儿的分离</p>
</li>
<li><p><code>单例</code>(Singleton Pattern)：模式起点：一个类只有一个实例，且提供一个访问全局点的方式，更加灵活地保证了实例的创建和访问约束，并且唯一约束的实施由类本身实例。典型应用：一个类只有一个实例，经常被应用于Facade模式，称为单例外观</p>
</li>
<li><p><code>命令</code>(Command Pattern)：模式起点：将请求封装为对象，从而将命令的执行和责任分开。典型应用：菜单系统</p>
</li>
<li><p><code>策略</code>(Strategy Pattern)：模式起点：将易于变化的部分封装为接口，通常Strategy封装一些运算法则，使之能互换。典型应用：数据层常考虑以策略提供算法和数据的分离</p>
</li>
<li><p><code>迭代器</code>(Iterator Pattern)：模式起点：在遍历算法中，迭代模式提供了遍历的顺序访问容器，GOF给出的定义为：提供一种方法访问容器对象中各个元素，而又无须暴露该对象的内部细节。典型应用：.NET中就是应用了迭代器来创建用于foreach的集合</p>
</li>
<li><p><code>模板方法</code>(Template Method Pattern)：模式起点：就是在父类中定义模板，然后由子类实现。典型应用：ASP.NET的Page类</p>
</li>
<li><p><code>观察者</code>(Observer Pattern)：模式起点：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。典型应用：在.NET中使用委托和事件可以更好的实现观察者模式</p>
</li>
<li><p><code>职责链</code>(Chain of Responsibility Pattern)：模式起点：将操作组成一个链表，通过遍历操作链表找到合适的处理器。通过统一的接口，被多个处理器实现，每个处理器都有后继处理器，可以将请求沿着处理器链传递。典型应用：GUI系统的事件传播</p>
</li>
<li><p><code>桥接</code>(Bridge Pattern)：模式起点：把实现和逻辑分开，对于我们深刻理解面向对象聚合复用的思想甚有助益。典型应用：多版本.NET Framework通过环境变量与对应版本应用建立桥梁</p>
</li>
<li><p><code>代理</code>(Proxy Pattern)：模式起点：将复杂的逻辑封装起来，通过代理对象控制实际对象的创建和访问，由代理对象屏蔽原有逻辑的复杂性，同时控制其可访问性。典型应用：WCF服务代理</p>
</li>
<li><p><code>装饰器</code>(Decorator Pattern)：模式起点：为原有系统，动态地增加或者删除状态和行为，在继承被装饰类的同时包含被装饰类的实例成员。典型应用：.NET中Stream的设计</p>
</li>
<li><p><code>门面</code>(Facade Pattern)：模式起点：将表现层和逻辑层隔离，封装底层的复杂处理，为用户提供简单的接口，这样的例子随处可见。门面模式很多时候更是一种系统架构的设计，在很多项目中，都实现了门面模式的接口，为复杂系统的解耦提供了最好的解决方案。典型应用：WSDL就是一个典型的平台无关的门面应用。</p>
</li>
<li><p><code>组合</code>(Composite Pattern)：模式起点：不管是个体还是组件，都包含公共的操作接口，通过同样的方式来处理一个组合中的所有对象。组件的典型操作包括：增加、删除、查找、分组和获取子元素等。典型应用：树形结构的数据结构。</p>
</li>
<li><p><code>适配器</code>(Adapter Pattern)：模式起点：在原类型不做任何改变的情况下，扩展了新的接口，灵活且多样的适配一切旧俗。典型应用：RCW(Runtime Callable Wrapper)在COM Interop中的应用</p>
</li>
<li><p><code>面向对象与基于对象</code>，二者的概念主要体现在：A、继承是区别面向对象与基于对象的核心所在，对于少了继承性的基于对象来说，自然少了多态性支持。B、封装是面向对象与基于对象的共同特征(C#与C++是面向对象语言，VB和Javascript是基于对象语言）</p>
</li>
<li><p><code>闭包</code>：主要是指由函数以及与函数相关的上下文环境组合而成的实体。通过闭包，函数与其上下文变量(又被称为自由变量，表示局部变量之外的变量)之间建立起关联关系，上下文变量的状态可以在函数的多次调用过程中持久保持。从作用域的角度而言，私有变量的生存期被延长，函数调用所生成的值在下次调用时仍被保持。从安全性的角度而言，闭包有利于信息的隐蔽，私有变量只在该函数内可见。</p>
</li>
<li><p><code>闭包与函数</code>：A、闭包是函数与其引用环境组合而成的实体。不同的引用环境和相同的函数可以组合产生不同的闭包实例。B、函数是一段可执行的代码体，在运行时不会由于上下文环境发生变化</p>
</li>
<li><p><code>闭包的优点</code>：A、代码简化，应用闭包可以实现一定程度的模块化复用，大大简化了代码执行的逻辑;B、数据共享与延迟；C、安全性。闭包的场合，有利于上下文信息的封闭性，实现了一定程度的信息隐蔽</p>
</li>
<li><p><code>闭包的缺点</code>：A、应用闭包，将不可避免地使程序逻辑变得复杂。B、很多时候，闭包的延迟特性会带来一定的逻辑问题</p>
</li>
<li><p>NET技术可以以<code>规范</code>和<code>实现</code>两部分来划分，我们经常强调和提起的.NET Framework,主要包括<code>公共语言运行时</code>(Common Language Runtime,CLR)和<code>.NET框架类库</code>(Framework Class Library, FCL)，其实是对.NET规范的实现。而另外一部分：规范，我们称之为<code>公共语言架构</code>(CLI,Common Language Infrastructure),主要包括<code>通用类型系统</code>(CTS)、<code>公共语言规范</code>(CLS,Common Language Specification)和<code>通用中间语言</code>(CIL,Common Intermediate Language)</p>
</li>
<li><p><code>通用类型系统的规则</code>：A、.NET中，所有的类型都继承自System.Object类；B、类型转换，通常有is和as两种模式，另外(typename)valuename,是通用方法；Convert类提供了灵活的类型转换封装；Parse方法，适用于将字符串类型转换为其他的基本类型；C、可以给类型创建别名</p>
</li>
<li><p><code>值类型</code>，通常分配在线程的堆栈上，并且不包含任何指向实例数据的指针，因为变量本身就包含了其实例数据。值类型包括简单类型、结构体类型和枚举类型。通常声明以下类型：int、char、float、long、bool、double、struct、enum、short、byte、decimal、sbyte、uint、ulong、ushort等时，该变量为值类型</p>
</li>
<li><p><code>引用类型</code>，分配在托管堆上，变量保存了实例数据的内存引用。引用类型可以是自描述类型、指针类型或接口类型。而自描述类型进一步细分成数组和类类型。类类型可以是用户定义的类、装箱的值类型和委托。通常声明为以下类型：class、interface、delegate、object、string以及其他的自定义引用类型时，该变量即为引用类型</p>
</li>
<li><p><code>内存分配简单描述</code>：A、值类型变量作为局部变量时，该实例将被创建在堆栈上；而如果值类型变量作为类型的成员变量时，它将作为类型实例数据的一部分，同该类型的其他字段都保存在托管堆上；B、引用类型变量数据保存在托管堆上，但是根据实例的大小有所区别，如果实例的大小小于85000Byte时，则该实例将创建在GC堆上；而当实例大小小于等于85000Byte时，则该实例创建在LOH(Large Object Heap)上</p>
</li>
<li><p><code>引用类型嵌套值类型</code>，则值类型作为引用类型实例的一部分，也分配在托管堆上；值类型嵌套引用类型，该引用类型将作为值类型的成员变量，堆栈上将保存该成员的引用，而成员的实际数据还是保存在托管堆中。结论：值类型实例总是分配在它声明的地方，声明为局部变量时其被分配在堆栈上，声明为引用类型成员时其被分配到托管堆上；引用类型实例则总是分配在托管堆上。</p>
</li>
<li><p><code>引用类型在性能上欠于值类型</code>，主要是因为以下几个方面：引用类型变量要分配于托管堆上；内存释放由GC完成，造成一定的GC堆压力；同时必须完成对其附加成员的内存分配过程；以及对象访问问题。</p>
</li>
<li><p><code>值类型的应用场合</code>：A、数据较小的场合；B、结构简单，不必在多态的情况下，值类型是较好的选择；C、类型的性质不表现出行为时，不必以类来实现；D、参数传递时，值类型默认情况下传递的是实例数据，而不是内存地址，因此数据传递情况下的选择，取决于函数内部的实现逻辑。E、如果类型的选择没有子类继承的必要，优先考虑值类型；F、在可能会引起装箱和拆箱的集合或队列中，值类型不是很好的选择，因为会引起对值类型的装箱操作，导致额外的内存的分配。</p>
</li>
<li><p><code>引用类型的场合</code>：A、适用于结构复杂、有继承、有多态、突出行为的场合；B、参数传递情况也是需要考虑的因素</p>
</li>
<li><p><code>隐式转换</code>：由低级类型向高级类型的转换过程。包括：值类型的隐式转换，主要是数值类型等基本类型的隐式转换；引用类型的隐式转换，主要是派生类向基类的转换；值类型和引用类型的隐式转换，主要指装箱和拆箱转换</p>
</li>
<li><p><code>显式转换</code>：也叫强制类型转换。但是转换过程不能保证数据的实整性，可能引起一定的精度损失或者引起不可知的异常发生。</p>
</li>
<li><p><code>值传递</code>：按值传递的实质是传递值，不同的是这个值在值类型和引用类型的表现是不同的；参数为值类型时，“值”为实例本身，困此传递的是实例拷贝，不会对原来的实例产生影响；参数为引用类型时，“值”为对象引用，因此传递的是引用地址拷贝，会改变原来对象的引用指向。</p>
</li>
<li><p><code>引用传递</code>：不管参数本身是值类型还是引用类型，按引用传递时，传递的是参数的地址，也就是实例的指针；如果参数是值类型，则按引用传递时，传递的是值类型变量的引用，因此在效果上类似于引用类型参数的按值传递方式，其实质为：值类型的按引用传递方式，实现的是对值类型参数实例的直接操作，方法调用方为该实例分配内存，而被调用方法操作该内存，也就是值类型的地址；而引用类型参数的按值传递方式，实现的是对引用类型的“值”引用指针的操作。</p>
</li>
<li><p><code>ref和out异同</code>：相同点：都是指示编译器传递实例指针，在表现行为上是相同的。不同点：使用的机制不同。ref要求传递之前参数必须显式初始化，而out不需要。</p>
</li>
<li><p>装箱的概念与拆箱的概念不是完全的互逆操作，从内存角度上来看，<code>拆箱</code>的性能开销<code>远小于装箱</code>，只是在实际的执行中，拆箱之后常常伴随着字段的拷贝</p>
</li>
<li><p>只有被装过箱的对象才能被拆箱，而并非所有的引用类型</p>
</li>
<li><p><code>CLR管理内存的区域</code>，主要有三块： A、线程的堆栈，用于分配值类型实例 B、GC堆，用于分配小对象实例 C、LOH(Large Object Heap)堆，用于分配大对象实例</p>
</li>
<li><p><code>垃圾回收的几种情况</code> A、内存不足溢出时，更确切地应该说是第0代对象充满时 B、调用GC.Collect方法强制执行垃圾回收 C、Windows报告内存不足时，CLR将强制执行垃圾回收 D、CLR卸载AppDomain时，GC将对所有代龄的对象执行垃圾回收 E、其他情况，例如物理内存不足，超出短期活代的内存段门限，运行主机拒绝分配内存等</p>
</li>
<li><p><code>垃圾回收小结</code>  </p>
<ol>
<li>CLR提供了一种分代式、标记清除型GC，利用标记清除算法来对不同代龄的对象进行垃圾收集和内存紧缩，保证了运算效率和执行优化  </li>
<li>一个对象没有被其他任何对象引用，则该对象被认为是可以回收的对象  </li>
<li>最好不要通过调用GC.Collect来强制执行垃圾回收  </li>
<li>垃圾对象并非立即被执行内存清理，GC可以在任何时候执行垃圾收集  </li>
<li>对”胖”对象考虑使用弱引用，以提高性能  </li>
</ol>
</li>
<li><p>常见的<code>非托管资源</code>包括<code>数据库连接</code>、<code>文件句柄</code>、<code>网络链接</code>、<code>互斥体</code>、<code>COM对象</code>、<code>套接字</code>、<code>位图</code>、<code>GDI+</code>对象等  </p>
</li>
<li><p><code>非托管资源</code>的<code>清理</code>主要有两种方式：<code>Finalize</code>方法和<code>Dispose</code>方法</p>
</li>
<li><p>Finalize方法总结  </p>
<ul>
<li>在C#中无法显示的重写Finalize方法，只能通过析构函数语法形式来实现  </li>
<li>struct中不允许定义析构函数，只有class中才可以，并且只能有一个  </li>
<li>Finalize方法不能被继承或重载</li>
<li>析构函数不能加任何修饰符，不能带参数，也不能被显式调用，唯一的例外是在子类重写时，通过base调用父类Finalize方法，而且这种方式也被隐式封装在析构函数中</li>
<li>执行垃圾回收之前系统会自动执行终止化操作  </li>
<li>Finalize方法中，可以实现使得被清理对象复活的机制，不过这种操作相当危险，而且没有什么实际意义，仅作参考，不推荐使用  </li>
</ul>
</li>
<li><p>最佳的资源清理策略，应该是同时实现Finalize方式和Dispose方式。一方面，Dispose方法可以克服Finalize方法在性能上的诸多弊病； 另一方面，Finalize方法又能够确保没显式调用Dispose方法时，也自行回收使用的所有资源。当然使用<code>using</code>语句简化了资源清理代码实现</p>
</li>
<li><p>Finalize方法和Dispose方法规则</p>
<ul>
<li>对于非托管资源的清理，Finalize由GC自行调用，而Dispose由开发者强制执行调用</li>
<li>尽量避免使用Finalize方式来清理资源，必须实现Finalize时，也应一并实现Dispose方法，来提供显式调用的控制权限  </li>
<li>通过GC.SuppressFinalize可以免除终结  </li>
<li>垃圾回收时，执行终结器的准确时间是不确定的，除非显式的调用Dispose或者Close方法  </li>
<li>强烈建议不要重写Finalize方法，同时强烈建议在任何非托管资源访问的类中同时实现终止化操作和Dispose模式  </li>
<li>Finalize方法和Dispose方法，只能清理非托管资源，释放内存的工作仍由GC负责  </li>
<li>对象使用完毕应该立即释放其资源，最好显式调用Dispose方法来实现  </li>
</ul>
</li>
<li><p>性能条款  </p>
<ul>
<li>推荐以Dispose模式来代替Finalize方式</li>
<li>选择合适的垃圾收集器：工作站GC和服务器GC  </li>
<li>在适当的情况下对对象实现弱引用 <code>WeakReference</code></li>
<li>尽可能以<code>using</code>来执行资源清理  </li>
<li>推荐使用泛型集合来代替非泛型集合  </li>
<li>初始化时最好为集合对象指定大小  </li>
<li>特定类型的<code>Array</code>性能优于<code>ArrayList</code></li>
<li>字符串驻留机制，是CLR为String类型实现的特殊设计  </li>
<li>合理使用<code>System.String</code>和<code>System.Text.StringBuilder</code>  </li>
<li>尽量在子类中重写<code>ToString</code>方法  </li>
<li>其他推荐的字符串操作，例如：<code>String.Equals</code>、<code>String.Compare</code></li>
<li><code>for</code>和<code>foreach</code>的选择 推荐使用 <code>foreach</code></li>
<li>以多线程处理应对系统设计  </li>
<li>尽可能少地抛出异常，禁止将异常处理放在循环内  </li>
<li>捕获异常时，catch块中尽量指定具体的异常筛选器，多个catch块应该保证异常由特殊到一般的排列顺序  </li>
<li>struct和class的性能比较</li>
<li>以is/as模式进行类型兼容性检查  </li>
<li>const和static readonly的权衡 const是编译时常量，readonly是运行时常量，所以const高效，readonly灵活，在实际的应用中，推荐以static readonly来代替const  </li>
<li>尽量避免不当的装箱和拆箱，选择合适的代替方案  </li>
<li>尽量使用一维零基数组  </li>
<li>以FxCop工具，检查你的代码  </li>
</ul>
</li>
<li></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-10-26T09:52:09.077Z" itemprop="dateUpdated">2020-10-26 17:52:09</time>
</span><br>


        
        此网站所有内容仅表示作者个人看法,如有说得不合看官心意的请多多谅解!
        
    </div>
    
    <footer>
        <a href="https://zhangjunhaocloud.github.io">
            <img src="/img/avatar.jpg" alt="张峻豪">
            张峻豪
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/" rel="tag">专业书籍</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%85%E8%AF%BB/" rel="tag">阅读</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/&title=《你必须知道的.NET》 — 云顶小栈&pic=https://zhangjunhaocloud.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/&title=《你必须知道的.NET》 — 云顶小栈&source=记录自己成长经历" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《你必须知道的.NET》 — 云顶小栈&url=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/&via=https://zhangjunhaocloud.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/09/06/%E6%97%B6%E9%97%B4%E8%A1%A8/2017-09-06/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">2017-09-16(小记)</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/07/18/NET/%E5%8A%A8%E6%80%81%E8%AE%BF%E9%97%AEWebService/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">动态访问WebService</h4>
      </a>
    </div>
  
</nav>



    

</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢客官~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>张峻豪 &copy; 2011 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/&title=《你必须知道的.NET》 — 云顶小栈&pic=https://zhangjunhaocloud.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/&title=《你必须知道的.NET》 — 云顶小栈&source=记录自己成长经历" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《你必须知道的.NET》 — 云顶小栈&url=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/&via=https://zhangjunhaocloud.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://zhangjunhaocloud.github.io/2017/07/21/%E9%98%85%E8%AF%BB/%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84.NET/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'stay hungry stay foolish！';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎您的光临!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
